using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

public class Grid : MonoBehaviour
{

    public GameObject nodeList;
    public float minDistance;
    public List<Node> Nodes = new List<Node>();

    void Start() {
        foreach (Transform child in nodeList.transform)
        {
            //Check if I exist
            if (Nodes.FindIndex(f => f.worldPosition == child.position) == -1) 
            {
                Nodes.Add(new Node(child.position, false));
            }
            
            MarkerNode markerNode = child.gameObject.GetComponent<MarkerNode>();

            foreach (GameObject neighbour in markerNode.neighbours)
            {
                if (Nodes.FindIndex(f => f.worldPosition == neighbour.transform.position) == -1) 
                {
                    Nodes.Add(new Node(neighbour.transform.position, false));
                }

                int intervals = (int)Math.Floor(Math.Abs(Vector3.Distance(child.position, neighbour.transform.position))/minDistance);
                if (intervals != 0) {
                    for (int i=1; i<=intervals; i++)
                    {
                        Vector3 newPos = child.position + ((neighbour.transform.position - child.position) * ((float)i/(float)(intervals+1)));
                        Vector3 lastPos = child.position + ((neighbour.transform.position - child.position) * ((float)(i-1)/(float)(intervals+1)));
                        //Debug.Log(i);
                        //Check if I exist
                        if (Nodes.FindIndex(f => f.worldPosition == (newPos)) == -1) 
                        {
                            Nodes.Add(new Node(newPos, true));
                        }

                        Nodes[Nodes.FindIndex(f => f.worldPosition == lastPos)].addNeighbour(Nodes[Nodes.FindIndex(f => f.worldPosition == newPos)]);
                        if (i == intervals)
                        {
                            Nodes[Nodes.FindIndex(f => f.worldPosition == newPos)].addNeighbour(Nodes[Nodes.FindIndex(f => f.worldPosition == neighbour.transform.position)]);
                        }

                    }
                } else {
                    Nodes[Nodes.FindIndex(f => f.worldPosition == child.position)].addNeighbour(Nodes[Nodes.FindIndex(f => f.worldPosition == neighbour.transform.position)]);
                }
            }
        }
    }


    void OnDrawGizmos() {

        foreach (Node n in Nodes) {
            Gizmos.color = (n.autoGenerated)?Color.red:Color.blue;
            Gizmos.DrawCube(n.worldPosition, (n.autoGenerated)?Vector3.one*0.2f:Vector3.one*0.5f);

            foreach (Node nh in n.neighbours) {
                Gizmos.color = Color.green;
                DrawArrow.ForGizmoTwoPoints(n.worldPosition, nh.worldPosition);
            }
        }
    }

}
